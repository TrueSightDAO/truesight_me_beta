#!/usr/bin/env node
/**
 * Comprehensive script to fetch all Wix CMS collections and export them as
 * JavaScript/JSON data files in the `data/` folder.
 *
 * Collections synced:
 * - AgroverseShipments (queryable)
 * - ExchangeRate (specific item IDs from SCHEMA.md)
 * - Statistics (queryable)
 * - EdgarModules (queryable)
 *
 * Usage:
 *   node scripts/syncAllWixData.js
 *
 * Requires .env file with:
 *   WIX_API_KEY=...
 *   WIX_SITE_ID=... (optional, defaults to TrueSight DAO)
 *   WIX_ACCOUNT_ID=... (optional, defaults to TrueSight DAO)
 */

require("dotenv").config();
const fs = require("fs");
const path = require("path");

const API_KEY = process.env.WIX_API_KEY;
const SITE_ID = process.env.WIX_SITE_ID || "d45a189f-d0cc-48de-95ee-30635a95385f";
const ACCOUNT_ID = process.env.WIX_ACCOUNT_ID || "0e2cde5f-b353-468b-9f4e-36835fc60a0e";

if (!API_KEY) {
  console.error("‚ùå Missing WIX_API_KEY in .env file.");
  process.exit(1);
}

const BASE_URL = "https://www.wixapis.com/wix-data/v2";
const HEADERS = {
  Authorization: API_KEY,
  "Content-Type": "application/json",
  "wix-site-id": SITE_ID,
  "wix-account-id": ACCOUNT_ID,
};
const OUTPUT_DIR = path.join(__dirname, "..", "data");
const INDEX_HTML_PATH = path.join(__dirname, "..", "index.html");

// ExchangeRate item IDs from SCHEMA.md
const EXCHANGE_RATE_ITEMS = {
  USD_TREASURY_BALANCE: "a0e7364c-716d-49f3-a795-647d2686a22b",
  TDG_ISSUED: "4088e994-2c06-42a8-a1cf-8cd77ee73203",
  ASSET_PER_TDG_ISSUED: "9b04879b-f06a-419a-9ad3-520ad60ea972",
  "30_DAYS_SALES": "956fdb46-bc8d-4c71-8e67-79813effbab3",
  TDG_USDC_PRICE: "8edde502-ac79-4e66-ab2d-8ebb99108665",
};

/**
 * Query all items from a collection
 */
async function queryCollection(collectionId) {
  const url = `${BASE_URL}/items/query?dataCollectionId=${collectionId}`;
  const body = {
    query: {
      paging: { limit: 1000, offset: 0 },
    },
  };

  const response = await fetch(url, {
    method: "POST",
    headers: HEADERS,
    body: JSON.stringify(body),
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ message: response.statusText }));
    throw new Error(`Failed to query ${collectionId} (${response.status}): ${error.message || response.statusText}`);
  }

  const payload = await response.json();
  return payload.dataItems || payload.items || [];
}

/**
 * Fetch a specific item by ID
 */
async function fetchItem(collectionId, itemId) {
  const url = `${BASE_URL}/items/${itemId}?dataCollectionId=${collectionId}`;
  const response = await fetch(url, {
    method: "GET",
    headers: HEADERS,
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ message: response.statusText }));
    throw new Error(`Failed to fetch item ${itemId} from ${collectionId} (${response.status}): ${error.message || response.statusText}`);
  }

  const payload = await response.json();
  return payload.dataItem?.data || null;
}

/**
 * Convert filename to valid JavaScript export name (camelCase)
 */
function toExportName(filename) {
  const baseName = path.basename(filename, ".js");
  return baseName.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
}

/**
 * Write data as regular JavaScript (not ES module) for <script src=""> inclusion
 */
function writeJSModule(filename, data, description) {
  const banner = `// Auto-generated by scripts/syncAllWixData.js on ${new Date().toISOString()}\n// ${description}\n// Do not edit by hand.\n\n`;
  const varName = toExportName(filename);
  const varLine = `const ${varName} = ${JSON.stringify(data, null, 2)};\n`;
  return fs.promises.writeFile(path.join(OUTPUT_DIR, filename), banner + varLine, "utf8");
}

/**
 * Write data as JSON
 */
function writeJSON(filename, data) {
  return fs.promises.writeFile(
    path.join(OUTPUT_DIR, filename),
    JSON.stringify(data, null, 2) + "\n",
    "utf8"
  );
}

/**
 * Sync AgroverseShipments collection
 */
async function syncAgroverseShipments() {
  console.log("üì¶ Fetching AgroverseShipments...");
  const items = await queryCollection("AgroverseShipments");
  const shipments = items
    .filter((item) => item?.data)
    .map((item) => ({
      id: item.data?._id || item.id || item._id || null,
      title: item.data?.title || "",
      contractUrl: item.data?.contract_url || "",
      status: item.data?.status || null,
      tags: item.data?.tags || [],
      updatedDate: item.data?.updatedDate || item.updatedDate || item._updatedDate || null,
      createdDate: item.data?.createdDate || item.createdDate || item._createdDate || null,
    }));

  await writeJSModule(
    "agroverse-shipments.js",
    shipments,
    "Agroverse shipment ledger metadata with Google Sheets URLs"
  );
  console.log(`   ‚úÖ Wrote ${shipments.length} shipments`);
  return shipments;
}

/**
 * Sync ExchangeRate collection (all items)
 */
async function syncExchangeRates() {
  console.log("üí± Fetching ExchangeRate collection...");
  const rates = {};

  try {
    // Query all items from the ExchangeRate collection
    const items = await queryCollection("ExchangeRate");
    
    items.forEach((item) => {
      if (!item?.data) return;
      
      const data = item.data;
      // Use description as key, fallback to _id if description is missing
      const key = data.description || data._id || item.id || item._id || `ITEM_${Object.keys(rates).length + 1}`;
      
      rates[key] = {
        id: data._id || item.id || item._id || null,
        description: data.description || key,
        exchangeRate: data.exchangeRate || null,
        currency: data.currency || null,
        updatedDate: data.updatedDate || data._updatedDate || item.updatedDate || item._updatedDate || null,
        createdDate: data.createdDate || data._createdDate || item.createdDate || item._createdDate || null,
      };
    });
    
    console.log(`   ‚úÖ Found ${Object.keys(rates).length} exchange rate items in collection`);
  } catch (err) {
    console.warn(`   ‚ö†Ô∏è  Failed to query ExchangeRate collection: ${err.message}`);
    // Fallback to individual item fetching if collection query fails
    console.log("   üîÑ Attempting fallback to individual item fetching...");
    for (const [key, itemId] of Object.entries(EXCHANGE_RATE_ITEMS)) {
      if (!itemId) continue;
      try {
        const data = await fetchItem("ExchangeRate", itemId);
        if (data) {
          rates[key] = {
            id: data._id || itemId,
            description: data.description || key,
            exchangeRate: data.exchangeRate || null,
            currency: data.currency || null,
            updatedDate: data.updatedDate || data._updatedDate || null,
          };
        }
      } catch (fetchErr) {
        console.warn(`   ‚ö†Ô∏è  Failed to fetch ${key} (${itemId}): ${fetchErr.message}`);
      }
    }
  }

  // Write as JavaScript module (for current usage)
  await writeJSModule(
    "exchange-rates.js",
    rates,
    "TrueSight DAO financial metrics and exchange rates"
  );
  
  // Write as JSON (for migration and future use)
  await writeJSON(
    "exchange-rates.json",
    {
      timestamp: new Date().toISOString(),
      description: "TrueSight DAO financial metrics and exchange rates from Wix CMS ExchangeRate collection",
      data: rates,
    }
  );
  
  // Update inlined data in index.html
  await updateIndexHtmlWithExchangeRates(rates);
  
  console.log(`   ‚úÖ Wrote ${Object.keys(rates).length} exchange rate items (JS + JSON + index.html)`);
  return rates;
}

/**
 * Update the inlined exchange rates data in index.html
 */
async function updateIndexHtmlWithExchangeRates(rates) {
  try {
    let htmlContent = await fs.promises.readFile(INDEX_HTML_PATH, "utf8");
    
    // Create a compact JSON string for inlining (minified)
    const compactJson = JSON.stringify(rates).replace(/\s+/g, " ");
    
    // Find and replace the exchangeRatesData constant
    const regex = /const exchangeRatesData = \{[\s\S]*?\};/;
    const replacement = `const exchangeRatesData = ${compactJson};`;
    
    if (regex.test(htmlContent)) {
      htmlContent = htmlContent.replace(regex, replacement);
      await fs.promises.writeFile(INDEX_HTML_PATH, htmlContent, "utf8");
      console.log(`   ‚úÖ Updated inlined exchange rates in index.html`);
    } else {
      console.warn(`   ‚ö†Ô∏è  Could not find exchangeRatesData in index.html to update`);
    }
  } catch (err) {
    console.warn(`   ‚ö†Ô∏è  Failed to update index.html: ${err.message}`);
  }
}

/**
 * Sync Statistics collection
 */
async function syncStatistics() {
  console.log("üìä Fetching Statistics...");
  try {
    const items = await queryCollection("Statistics");
    const stats = items
      .filter((item) => item?.data)
      .map((item) => ({
        id: item.data?._id || item.id || item._id || null,
        ...item.data,
        updatedDate: item.data?.updatedDate || item.updatedDate || item._updatedDate || null,
        createdDate: item.data?.createdDate || item.createdDate || item._createdDate || null,
      }));

    await writeJSModule(
      "statistics.js",
      stats,
      "Website statistics for Agroverse and TrueSight sites"
    );
    console.log(`   ‚úÖ Wrote ${stats.length} statistics items`);
    return stats;
  } catch (err) {
    console.warn(`   ‚ö†Ô∏è  Failed to query Statistics collection: ${err.message}`);
    return [];
  }
}

/**
 * Sync EdgarModules collection
 */
async function syncEdgarModules() {
  console.log("ü§ñ Fetching EdgarModules...");
  try {
    const items = await queryCollection("EdgarModules");
    const modules = items
      .filter((item) => item?.data)
      .map((item) => ({
        id: item.data?._id || item.id || item._id || null,
        title: item.data?.title || item.data?.name || item.data?.module_name || "",
        description: item.data?.moduleDescription || item.data?.description || item.data?.desc || item.data?.module_description || item.data?.summary || "",
        demoUrl: item.data?.interface || item.data?.demo_url || item.data?.demoUrl || item.data?.demo || item.data?.view_demo || item.data?.demo_link || "",
        sourceUrl: item.data?.googleAppScript || item.data?.source_url || item.data?.sourceUrl || item.data?.source || item.data?.github_url || item.data?.github || item.data?.source_code || item.data?.source_link || "",
        order: item.data?.order || item.data?.sort_order || item.data?.display_order || 999,
        tags: item.data?.tags || [],
        updatedDate: item.data?._updatedDate || item.data?.updatedDate || item.updatedDate || item._updatedDate || null,
        createdDate: item.data?._createdDate || item.data?.createdDate || item.createdDate || item._createdDate || null,
      }))
      .sort((a, b) => (a.order || 999) - (b.order || 999));

    await writeJSModule(
      "edgar-modules.js",
      modules,
      "Edgar platform modules with demo and source code links"
    );
    console.log(`   ‚úÖ Wrote ${modules.length} Edgar modules`);
    return modules;
  } catch (err) {
    console.warn(`   ‚ö†Ô∏è  Failed to query EdgarModules collection: ${err.message}`);
    return [];
  }
}

/**
 * Main sync function
 */
async function main() {
  console.log("üîÑ Syncing all Wix CMS collections...\n");
  await fs.promises.mkdir(OUTPUT_DIR, { recursive: true });

  const results = {
    timestamp: new Date().toISOString(),
    collections: {},
  };

  try {
    results.collections.agroverseShipments = await syncAgroverseShipments();
  } catch (err) {
    console.error(`   ‚ùå AgroverseShipments sync failed: ${err.message}`);
  }

  try {
    results.collections.exchangeRates = await syncExchangeRates();
  } catch (err) {
    console.error(`   ‚ùå ExchangeRate sync failed: ${err.message}`);
  }

  try {
    results.collections.statistics = await syncStatistics();
  } catch (err) {
    console.error(`   ‚ùå Statistics sync failed: ${err.message}`);
  }

  try {
    results.collections.edgarModules = await syncEdgarModules();
  } catch (err) {
    console.error(`   ‚ùå EdgarModules sync failed: ${err.message}`);
  }

  // Write summary JSON
  await writeJSON("sync-summary.json", results);

  console.log("\n‚úÖ Sync complete!");
  console.log(`   Output directory: ${OUTPUT_DIR}`);
}

main().catch((err) => {
  console.error("\n‚ùå Sync failed:", err.message);
  process.exit(1);
});

